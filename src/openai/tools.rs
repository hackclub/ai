use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(untagged)]
pub enum ToolChoice {
    String(String),
    Object {
        #[serde(skip_serializing_if = "Option::is_none")]
        function: Option<ToolChoiceFunction>,
    },
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ToolChoiceFunction {
    /// The name of the function to call.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Tool {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub function: Option<Function>,

    /// HTTP headers to send with requests to the MCP server (optional for MCP tools).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub headers: Option<Value>,

    /// A human-readable label for the MCP server (optional for MCP tools).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server_label: Option<String>,

    /// The URL of the MCP server to connect to (required for MCP tools).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server_url: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#type: Option<String>,
}

/// A function, this is the same schema for both tools and the deprecated functions api. this
/// is duplicated in functions
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Function {
    /// A description of what the function does, used by the model to choose when and how to call the function.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Function parameters defined as a JSON Schema object. Refer to [this](https://json-schema.org/understanding-json-schema) for schema documentation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<Value>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "lowercase")]
pub enum ToolType {
    Function,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ToolCall {
    /// The function that the model called.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub function: Option<FunctionCall>,

    /// The ID of the tool call.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The type of the tool. Currently, only function is supported.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#type: Option<ToolType>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct FunctionCall {
    /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option<String>,

    /// The name of the function to call.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}
